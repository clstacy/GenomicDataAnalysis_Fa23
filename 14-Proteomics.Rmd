---
editor_options: 
  markdown: 
    wrap: 72
---

# Proteomic Analysis with limma

last updated: `r Sys.Date()`

```{r setup-limma, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
set.seed("1492")
```

**Install Packages**

As usual, make sure we have the right packages for this exercise

```{r ready-packages-limma, cache=FALSE}
if (!require("pacman")) install.packages("pacman"); library(pacman)

# let's load all of the files we were using and want to have again today
p_load("tidyverse", "knitr", "readr",
       "pander", "BiocManager", 
       "dplyr", "stringr", 
       "statmod", # required dependency, need to load manually on some macOS versions.
       "Glimma", # beautifies limma results
       "purrr", # for working with lists (beautify column names)
       "reactable") # for pretty tables.

# We also need these Bioconductor packages today.
p_load("edgeR", "AnnotationDbi", "org.Sc.sgd.db", "ggVennDiagram")
p_load("janitor")
p_load("UpSetR")
p_load("ComplexHeatmap")
p_load("enrichplot")
p_load("clusterProfiler")
#NOTE: edgeR loads limma as a dependency
```

## Description

Use limma to identify differential patterns of proteomic and
transcriptomic changes in response to stress.

## Learning Objectives

At the end of this exercise, you should be able to:

-   Generate a table of sample metadata.
-   Filter low counts and normalize count data.
-   Utilize the limma package to identify differentially expressed
    \_\_\_\_\_\_\_.

```{r load-libraries-limma}
library(limma)
library(org.Sc.sgd.db)
# for ease of use, set max number of digits after decimal
options(digits=3)
```

## Loading in the count data file

*We are downloading the counts for the non-subsampled fastq files from a
Github repository using the code below. Just as in previous exercises,
assign the data to the variable `counts`. You can change the file path
if you have saved it to your computer in a different location.*

```{r load-fc-limma, error=TRUE}
# counts <- read.delim('https://github.com/clstacy/GenomicDataAnalysis_Fa23/raw/main/data/ethanol_stress/counts/salmon.gene_counts.merged.nonsubsamp.tsv',
#     sep = "\t",
#     header = T,
#     row.names = 1
#   )

proteome_HS <- read.delim("~/Documents/GitHub/GenomicDataAnalysis_Fa23/data/heat_shock/proteomic_FC/HS_Proteomics_Data.txt",
                          sep="\t",
                          header=T,
                          row.names=1)


```

To find the order of files we need, we can get just the part of the
column name before the first "." symbol with this command:

```{r identify-sampleOrder-limma}
str_split_fixed(counts %>% colnames(), "\\.", n = 2)[, 1]
```

```{r generate-metadata-limma}

# generate metadata from proteme data
sample_metadata_proteome <- proteome_HS |>
  colnames() |> # use column names of data
  stringr::str_split(pattern="Rep", # split names based on character pattern
                     simplify = T) |> # Convert to a matrix
  as_tibble(.name_repair = "unique") |> # convert to a data.frame
  setNames(c("Time", "Replicate")) |> # add column nmaes
  mutate(Sample = colnames(proteome_HS), # add column with original sample name
         Measure = "protein", # denote these values as proteomic
         Time = readr::parse_number(Time) # make time a number
         ) |>
  mutate(Time=as.factor(Time)) #convert time to a factor
  relocate(Sample)


```

Now, let's create a design matrix with this information

```{r designMatrix-proteome}
time <- sample_metadata_proteome$Time
replicate <- sample_metadata_proteome$Replicate
design <- model.matrix(~ 0 + time + replicate)

design
```

Because our values aren't counts, we can't use edgeR to load the values
in.

```{r}
fit <- lmFit(proteome_HS, design)
fit$coef

fit$genes <- fit$genes[,c("ProbeName","Symbol","EntrezID")]




# generate contrasts we are interested in learning about
my.contrasts <- makeContrasts(time5 = time5 - time0, 
                     time10 = time10 - time0,
                     time15 = time15 - time0,
                     time30 = time30 - time0,
                     time45 = time45 - time0,
                     time60 = time60 - time0,
                     time90 = time90 - time0,
                     time120 = time120 - time0,
                      time240 = time240 - time0,
                     levels=design)

# fit the linear model to these contrasts
res_all <- contrasts.fit(fit, my.contrasts)

# This looks at all of our contrasts in my.contrasts
res_all <- treat(res_all,
                 fc = 1.2,
                 robust = TRUE)

# get top results
top.table <- topTable(res_all, sort.by = "p", n = Inf)
head(top.table, 20)

top.table %>% 
  tibble() %>% 
  arrange(adj.P.Val) %>%
  mutate(across(where(is.numeric), signif, 3)) %>%
  View()

summary(decideTests(res_all))

res_all |>
  decideTests() |> 
  data.frame() |>
  tibble::rownames_to_column("ORF") |>
  tidyr::pivot_longer(-ORF,names_to="Time", values_to = "DE_direction") |>
  mutate(Time = readr::parse_number(Time)) |>
  group_by(Time, DE_direction) |>
  filter(DE_direction != 0) |>
  #group_by(Time) |>
  summarise(n=n(),genes=toString(ORF)) |> View()

```

```{r}
plot_summary_bars_proteome <- print(res_all |>
  decideTests(p.value = 0.05, lfc = 0) %>%
  as.data.frame() %>%
  rownames_to_column("gene") %>%
  pivot_longer(-gene, names_to = "contrast", values_to = "DE_direction") %>%
  group_by(contrast) %>%
  summarise(
    upregulated = sum(DE_direction == 1),
    downregulated = sum(DE_direction == -1)
  ) %>%
  pivot_longer(-contrast, names_to = "DE_direction", values_to = "n_genes") %>%
  mutate(contrast_temp = readr::parse_number(contrast)) |> 
ggplot(aes(
  x = fct_rev(as.factor(contrast_temp)),
  y = n_genes,
  fill = DE_direction
)) +
  geom_col(position = "dodge") +
  theme_bw() +
  coord_flip() +
  geom_text(aes(label = n_genes),
            position = position_dodge(width = .9),
            hjust = "inward") +
  labs(y = "Number of DE genes") +
      ggtitle("Summary of protein level changes over time"))
```


```{r}
# Visualization inspired by: https://tomsing1.github.io/blog/posts/upset_plots/

# save decideTests output
results <- res_all |>
  decideTests(p.value = 0.05, lfc = 0)
# remove genes not signif. in any contrast
results <- results[rowSums(abs(results)) > 0, ]

# calculate the intersection between the differentially expressed gene sets
m <- ComplexHeatmap::make_comb_mat(abs(results), mode = "distinct")
# exclude self-intersects (total # of diff. genes will be displayed separately)
m <- m[ComplexHeatmap::comb_degree(m) > 1]
(ss <- ComplexHeatmap::set_size(m))
(cs <- ComplexHeatmap::comb_size(m))

ht <- UpSet(m, 
      set_order = colnames(m), 
      comb_order = order(comb_degree(m)),
      top_annotation = HeatmapAnnotation(
        "Distinct diff. genes" = anno_barplot(
          cs, 
          ylim = c(0, max(cs)*1.1),
          border = FALSE, 
          gp = gpar(fill = "black"), 
          height = unit(4, "cm")
        ), 
        annotation_name_side = "left", 
        annotation_name_rot = 90),
      right_annotation = HeatmapAnnotation(
        which = "row",
        "Total" = anno_barplot(
          ss, 
          ylim = c(0, max(ss)*1.1),
          border = FALSE, 
          gp = gpar(fill = "black"), 
          width = unit(4, "cm")
        )
      ),
      column_title = "Intersection between DE proteins (Protein Expression)"
)
ht = draw(ht)
od = column_order(ht)
rod = row_order(ht)
decorate_annotation("Distinct diff. genes", {
  grid.text(cs[od], 
            x = seq_along(cs), 
            y = unit(cs[od], "native") + unit(2, "pt"), 
            default.units = "native", just = c("left", "bottom"), 
            gp = gpar(fontsize = 8, col = "#404040"), rot = 45)
})
decorate_annotation("Total", {
  grid.text(ss[rod], 
            x = unit(ss[rod], "native") + unit(20, "pt"), 
            y = rev(seq_along(ss)), 
            default.units = "native", just = c("right", "bottom"), 
            gp = gpar(fontsize = 8, col = "#404040"))
})

# upregulated

# remove genes not signif. in any contrast
results_up <- results[rowSums(results) > 0, ]

# calculate the intersection between the differentially expressed gene sets
m <- ComplexHeatmap::make_comb_mat(abs(results_up), mode = "distinct")
# exclude self-intersects (total # of diff. genes will be displayed separately)
m <- m[ComplexHeatmap::comb_degree(m) > 1]
(ss <- ComplexHeatmap::set_size(m))
(cs <- ComplexHeatmap::comb_size(m))

ht <- UpSet(m, 
      set_order = colnames(m), 
      comb_order = order(comb_degree(m)),
      top_annotation = HeatmapAnnotation(
        "Distinct diff. genes" = anno_barplot(
          cs, 
          ylim = c(0, max(cs)*1.1),
          border = FALSE, 
          gp = gpar(fill = "black"), 
          height = unit(4, "cm")
        ), 
        annotation_name_side = "left", 
        annotation_name_rot = 90),
      right_annotation = HeatmapAnnotation(
        which = "row",
        "Total" = anno_barplot(
          ss, 
          ylim = c(0, max(ss)*1.1),
          border = FALSE, 
          gp = gpar(fill = "black"), 
          width = unit(4, "cm")
        )
      ),
      column_title = "Intersection between UPREGULATED proteins (Protein Expression)"
)
ht = draw(ht)
od = column_order(ht)
rod = row_order(ht)
decorate_annotation("Distinct diff. genes", {
  grid.text(cs[od], 
            x = seq_along(cs), 
            y = unit(cs[od], "native") + unit(2, "pt"), 
            default.units = "native", just = c("left", "bottom"), 
            gp = gpar(fontsize = 8, col = "#404040"), rot = 45)
})
decorate_annotation("Total", {
  grid.text(ss[rod], 
            x = unit(ss[rod], "native") + unit(20, "pt"), 
            y = rev(seq_along(ss)), 
            default.units = "native", just = c("right", "bottom"), 
            gp = gpar(fontsize = 8, col = "#404040"))
})

# downregulated

# remove genes not signif. in any contrast
results_down <- results[rowSums(results) < 0, ]

# calculate the intersection between the differentially expressed gene sets
m <- ComplexHeatmap::make_comb_mat(abs(results_down), mode = "distinct")
# exclude self-intersects (total # of diff. genes will be displayed separately)
m <- m[ComplexHeatmap::comb_degree(m) > 1]
(ss <- ComplexHeatmap::set_size(m))
(cs <- ComplexHeatmap::comb_size(m))

ht <- UpSet(m, 
      set_order = colnames(m), 
      comb_order = order(comb_degree(m)),
      top_annotation = HeatmapAnnotation(
        "Distinct diff. genes" = anno_barplot(
          cs, 
          ylim = c(0, max(cs)*1.1),
          border = FALSE, 
          gp = gpar(fill = "black"), 
          height = unit(4, "cm")
        ), 
        annotation_name_side = "left", 
        annotation_name_rot = 90),
      right_annotation = HeatmapAnnotation(
        which = "row",
        "Total" = anno_barplot(
          ss, 
          ylim = c(0, max(ss)*1.1),
          border = FALSE, 
          gp = gpar(fill = "black"), 
          width = unit(4, "cm")
        )
      ),
      column_title = "Intersection between DOWNREGULATED proteins (Protein Expression)"
)
ht = draw(ht)
od = column_order(ht)
rod = row_order(ht)
decorate_annotation("Distinct diff. genes", {
  grid.text(cs[od], 
            x = seq_along(cs), 
            y = unit(cs[od], "native") + unit(2, "pt"), 
            default.units = "native", just = c("left", "bottom"), 
            gp = gpar(fontsize = 8, col = "#404040"), rot = 45)
})
decorate_annotation("Total", {
  grid.text(ss[rod], 
            x = unit(ss[rod], "native") + unit(20, "pt"), 
            y = rev(seq_along(ss)), 
            default.units = "native", just = c("right", "bottom"), 
            gp = gpar(fontsize = 8, col = "#404040"))
})
```


### Gene Set Enrichment

Now we have a list of genes that correspond to the peaks seen in treatment but not control. Let's see if there are any enrichments in this gene list, using techniques we have used already in class.

We now have multiple lists of genes (proteins) that we can run enrichment analysis on.

It looks like at 30 minutes we are starting to see a significant number of proteins being differentially expressed proteins.

Let's pull the names of genes corresponding to proteins that are upregulated at t=30 minutes.

```{r}
ID_protein_up_30min <- results |>
  data.frame() |>
  dplyr::filter(time30==1) |>
  rownames()
```

#### Gene Ontology

We'll use `enrichGO` from `clusterProfiler` just as we did in the gene ontology lesson.

```{r}
# Run GO enrichment
go_results <- clusterProfiler::enrichGO(
  gene = ID_protein_up_30min,
  OrgDb = "org.Sc.sgd.db",
  keyType = "ORF",
  ont = "ALL"
) |>
  # let's add a 'richFactor' column that gives us the proportion of genes DE in the term
  mutate(richFactor = Count / as.numeric(sub("/\\d+", "", BgRatio)))

# take a peak at the results
head(go_results)

# create a table for the html file
data.frame(go_results) %>% View()

# visualize top GO terms
ggplot(go_results,
       showCategory = 15,
       aes(richFactor, fct_reorder(Description, richFactor))) +
  geom_segment(aes(xend = 0, yend = Description)) +
  geom_point(aes(color = p.adjust, size = Count)) +
  scale_color_gradientn(
    colours = c("#f7ca64", "#46bac2", "#7e62a3"),
    trans = "log10",
    guide = guide_colorbar(reverse = TRUE, order = 1)
  ) +
  scale_size_continuous(range = c(2, 10)) +
  xlab("Rich Factor") +
  ylab(NULL) +
  ggtitle("Enriched GO Categories") +
  theme_bw()
```


#### KEGG

Run KEGG enrichment on the same gene list.

```{r enrich-KEGG-chip}
# Run our KEGG enrichment
kegg_results <- clusterProfiler::enrichKEGG(gene = ID_protein_up_30min,
                           organism = 'sce' #options: https://www.genome.jp/kegg/catalog/org_list.html
                           )

# take a peak at the results
head(kegg_results)

# create a table for the html file
data.frame(kegg_results) %>% View()


# Remove " - Saccharomyces cerevesiae" from each description entry
kegg_results@result$Description <- kegg_results@result$Description %>% print() %>% str_replace_all(., fixed(" - Saccharomyces cerevisiae"), "")


# browseKEGG(kegg_results, 'sce04213')  # longevity
# browseKEGG(kegg_results, 'sce00500')  # Starch and sucrose metabolism


dotplot(kegg_results, showCategory = 10) 
```

Cool, but that was only at the 30 minutes, do we have to do this for each gene list individually?

Thankfully not, we can input a list of gene names into `compareCluster` and call `enrichGO` or `enrichKEGG`. We do want to be cautious to not be p-hacking. I'm not necessarily interested in all of the time points. Rather than fishing, there are a few I want to see, so we can just make them all.

```{r}
ID_proteins_list <- results %>%
  data.frame() %>%
  tibble::rownames_to_column("ORF") %>%
  tidyr::pivot_longer(-ORF,names_to="Time", values_to = "DE_direction") %>%
  mutate(Time = readr::parse_number(Time),
         DE_name = case_when(DE_direction == 1 ~ "up",
                             DE_direction == -1 ~ "down",
                             TRUE~NA),
         group=paste0("DE_",DE_name,"_0",Time, "min")) %>%
  # modify names to fix order
  mutate(group = str_replace(group,"_0120", "_120")) %>%
  mutate(group = str_replace(group,"_0240", "_240")) %>%
  mutate(entrezID=AnnotationDbi::select(org.Sc.sgd.db,keys=ORF,columns="ENTREZID",
      multiVals = "first")$ENTREZID) %>%
  group_by(group) %>%
  filter(DE_direction != 0) %>%
  group_split() %>% # split into many lists
  purrr::set_names(purrr::map_chr(., ~.x$group[1])) %>% # assign names
  # get just the ORF names
  map(., ~ .x |> pull(all_of("ORF")))
```


Run GO enrichment on all groups at once
```{r fig.height=18, fig.width=8, dpi=300}
# Run GO enrichment
test_enrich <- clusterProfiler::compareCluster(
                                  geneCluster   = ID_proteins_list, 
                                  ont           = "BP",
                                  OrgDb         = org.Sc.sgd.db,
                                  pAdjustMethod = "BH",
                                  pvalueCutoff  = 0.01,
                                  qvalueCutoff  = 0.05,
                                  readable      = FALSE,
                                  fun           = 'enrichGO',
                                  keyType       = 'ORF'
                                  )  |>
  # let's add a 'richFactor' column that gives us the proportion of genes DE in the term
  mutate(richFactor = Count / as.numeric(sub("/\\d+", "", BgRatio)))


dotplot(test_enrich,
        # label_format = 10,
        showCategory=5
        # if we choose "ALL", we can show them all with facet.
        #facet="ONTOLOGY",
        # strip_width=10
        ) +
  scale_x_discrete(guide = guide_axis(angle = 60))

```

```{r fig.height=16, fig.width=12, dpi=600}
# take a peak at the results
head(test_enrich)

# create a table for the html file
data.frame(test_enrich) %>% View()

# visualize top GO terms
test_enrich %>%
  as.data.frame() %>% 
  group_by(Cluster) %>%
  # grab the top 10 GO terms per time point
  slice_min(order_by=p.adjust, n = 10) %>%
  separate_wider_delim(Cluster, delim = "_", names = c("junk","DE", "time")) %>%
  ggplot(.,
           showCategory = 5,
           aes(richFactor, fct_reorder(Description, richFactor))) +
      geom_segment(aes(xend = 0, yend = Description)) +
      geom_point(aes(color = p.adjust, size = Count)) +
      scale_color_gradientn(
        colours = c("#f7ca64", "#46bac2", "#7e62a3"),
        trans = "log10",
        guide = guide_colorbar(reverse = TRUE, order = 1)
      ) +
      scale_size_continuous(range = c(2, 10)) +
      scale_y_discrete(labels = function(x) str_wrap(x, width = 30)) +
      xlab("Rich Factor") +
      ylab(NULL) +
      ggtitle("Enriched GO Categories") +
      facet_grid(rows = vars(DE), cols = vars(time), scales = "free_y") +
      theme_bw()

# get rid of sticks to save space
test_enrich %>%
  as.data.frame() %>% 
  group_by(Cluster) %>%
  slice_min(order_by=p.adjust, n = 10) %>%
  separate_wider_delim(Cluster, delim = "_", names = c("junk","DE", "time")) %>%
  mutate(Time = readr::parse_number(time)) %>%
  ggplot(.,
           aes(as.factor(Time), fct_reorder(Description, richFactor))) +
      geom_point(aes(color = p.adjust, size = Count)) +
      scale_color_gradientn(
        colours = c("#f7ca64", "#46bac2", "#7e62a3"),
        trans = "log10",
        guide = guide_colorbar(reverse = TRUE, order = 1)
      ) +
      scale_size_continuous(range = c(2, 12)) +
      scale_y_discrete(labels = function(x) str_wrap(x, width = 25)) +
      xlab("Time (minutes)") +
      ylab(NULL) +
      ggtitle("Enriched GO Categories") +
      facet_wrap(~DE, scales = "free_y") +
      theme_bw() +
      theme(text = element_text(size=14))
```


If we wanted to generate a heatmap from these values, we can do that as well. Let's start from our `res_all` object, which contains the estimated log2FC values for each gene in each contrast
```{r}
library(ComplexHeatmap)

res_all_matrix <- res_all %>%
  as.matrix()
```
Using k-means clustering, we can find optimal k
```{r}

library(readr)
library(factoextra)
library(NbClust)

## Elbow method
fviz_nbclust(scale(res_all_matrix), kmeans, method = "wss") +
    geom_vline(xintercept = 4, linetype = 2)+
  labs(subtitle = "Elbow method")

## Silhouette method
fviz_nbclust(scale(res_all_matrix), kmeans, method = "silhouette")+
  labs(subtitle = "Silhouette method")

## Gap statistic
# nboot = 50 to keep the function speedy. 
# recommended value: nboot= 500 for your analysis.
# Use verbose = FALSE to hide computing progression.
set.seed(123)
fviz_nbclust(res_all_matrix, kmeans, nstart = 25,  method = "gap_stat", nboot = 50)+
  labs(subtitle = "Gap statistic method")
```


Let's use `k=4`.
```{r}
library(RColorBrewer)
set.seed(123)

heatmap_protein <- res_all_matrix %>%
  as.data.frame() %>%
  rownames_to_column("ORF") %>%
  # get names of genes different at any time point
  dplyr::filter(ORF %in% list_c(ID_proteins_list)) %>%
  column_to_rownames("ORF") %>%
  data.matrix() %>%
  # scale(center=TRUE, scale=TRUE) %>%
  ComplexHeatmap::pheatmap(cluster_cols=F,
                           clustering_distance_rows = "correlation", 
                           #clustering_distance_cols = "correlation",
    row_km = 4,
    column_km = 3,
    show_rownames = F,
    # color = rev(brewer.pal(5, "RdBu")),
    colorRampPalette(c(
      "blue",
      "white",
      "red"
    ))(25
    ),
    main = "Clustering of Protein levels of DE proteins over time",
    # scale = "row", # Scale values in the direction of genes (rows)
    breaks = c(-4,4),
        heatmap_legend_param = list(direction = "horizontal", title="log2FC")
  )

# add the legend to bottom of the plot, and generate
draw_heat_protein <- draw(heatmap_protein,
    heatmap_legend_side = "bottom")

# view the plot
draw_heat_protein 
```


```{r}
clusterlist = row_order(draw_heat_protein)

# create empty list to store
clusters_gene_list <- list()

# get gene names for each cluster
for (cluster in as.character(1:length(clusterlist))) {
  clusters_gene_list[[paste0("Cluster:",cluster)]] <- heatmap_protein@row_names_param$labels[clusterlist[[cluster]]]
}


# run GO enrichment
heatmap_GO <- clusterProfiler::compareCluster(geneCluster = clusters_gene_list, 
                                  ont           = "ALL",
                                  OrgDb = org.Sc.sgd.db,
                                  pAdjustMethod = "BH",
                                  pvalueCutoff  = 0.01,
                                  qvalueCutoff  = 0.05,
                                  readable      = FALSE,
                                  fun =  'enrichGO',
                                  keyType       = 'ORF',
                                  universe      = rownames(res_all_matrix)
                                  )  |>
  # let's add a 'richFactor' column that gives us the proportion of genes DE in the term
  mutate(richFactor = Count / as.numeric(sub("/\\d+", "", BgRatio)))


# look at top terms for each cluster
heatmap_GO %>%
  as.data.frame() %>% 
  group_by(Cluster) %>%
  slice_min(order_by=p.adjust, n = 10) %>%
  View()
```

Finally, let's get a correlation matrix of all of these different time points. We see time the weakest correlation between the first and final time point, as expected. Furthermore, there appears to be rapid changes occuring at early time points, where later time points 
```{r}
res_all_matrix %>%
  cor(use="pairwise.complete.obs") %>%
  corrplot::corrplot(method = "square", insig='blank',
         addCoef.col ='white', number.cex = 0.8,
         tl.srt=45,
         title="Correlation of Protein Expression between Time points in Heat Shock",
         # add this to make sure title isn't cut off
         mar=c(0,0,2,0))
```


## Transcriptomic Time Series response to Heat Shock

Let's grab a dataset of the transcriptome for time series response to heat shock. Our lab doesn't have this data, so we are using an old micro-array dataset from https://doi.org/10.1534/genetics.109.107268. 

### load in the data

```{r}
transcriptome_HS <- read.delim("~/Documents/GitHub/GenomicDataAnalysis_Fa23/data/heat_shock/Eng_2010_HS_Arrays.tsv",
                          sep="\t",
                          header=T,
                          row.names=1,
                          check.names = F) |>
  # there are some empty columns in the file, so we trim those off now
  janitor::remove_empty()
```

Now, let's generate some metadata for this dataset as well.
```{r}
# generate metadata from Array expression data
sample_metadata_transcriptome <- transcriptome_HS |>
  colnames() |> # use column names of data
  stringr::str_split(pattern=" Rep", # split names based on character pattern
                     simplify = T) |> # Convert to a matrix
  as_tibble(.name_repair = "unique") |> # convert to a data.frame
  setNames(c("Time", "Replicate")) |> # add column nmaes
  mutate(Sample = colnames(transcriptome_HS), # add column with original sample name
         Measure = "RNA", # denote these values as proteomic
         Time = as.factor(readr::parse_number(Time)) # make time a factor
         ) %>%
  # mutate()
  relocate(Sample)
```

### Design matrix

Now, let's create a design matrix with this information

```{r designMatrix-proteome}
time_transcriptome <- sample_metadata_transcriptome$Time
replicate_transcriptome <- sample_metadata_transcriptome$Replicate
design_transcriptome <- model.matrix(~ 0 + time_transcriptome + replicate_transcriptome)

# beautify column names
colnames(design_transcriptome) <- colnames(design_transcriptome) %>% 
  str_replace_all("_transcriptome","")
design_transcriptome
```

Because our values aren't counts, we can't use `edgeR` to load the values
in.

```{r}
# fit linear model with limma
fit_transcriptome <- lmFit(transcriptome_HS, design_transcriptome)

# assign gene names
fit_transcriptome$genes <- fit_transcriptome$genes[,c("ProbeName","Symbol","EntrezID")]


# generate contrasts we are interested in learning about
my.contrasts_transcriptome <- makeContrasts(time5 = time5, 
                     time15 = time15,
                     time30 = time30,
                     time45 = time45,
                     time60 = time60,
                     time120 = time120,
                     levels=design_transcriptome)

# fit the linear model to these contrasts
res_all_transcriptome <- contrasts.fit(fit_transcriptome, my.contrasts_transcriptome)

# Run treat on all contrasts
res_all_transcriptome <- treat(res_all_transcriptome,
                               lfc=1, # higher than for proteome, since more differences
                               robust=TRUE)

# get top results
top.table <- topTreat(res_all_transcriptome, sort.by = "p", n = Inf)
head(top.table, 20)

top.table %>%
  as_tibble(rownames = "ORF") %>%
  arrange(adj.P.Val) %>%
  mutate(across(where(is.numeric), signif, 3)) %>%
  View()

summary(decideTests(res_all_transcriptome))

res_all_transcriptome |>
  decideTests() |> 
  data.frame() |>
  tibble::rownames_to_column("ORF") |>
  tidyr::pivot_longer(-ORF,names_to="Time", values_to = "DE_direction") |>
  mutate(Time = readr::parse_number(Time)) |>
  group_by(Time, DE_direction) |>
  filter(DE_direction != 0) |>
  summarise(n=n(),genes=toString(ORF)) |> 
  View()

```

We could visualize these results in all of the ways we did above, but for brevity, let's just make one plot:

```{r}
plot_summary_bars_transcriptome <- print(
  res_all_transcriptome |>
  decideTests(p.value = 0.05, lfc = 0) %>%
  as.data.frame() %>%
  rownames_to_column("gene") %>%
  pivot_longer(-gene, names_to = "contrast", values_to = "DE_direction") %>%
  group_by(contrast) %>%
  # because there are NA values, we need to drop those now:
  drop_na() %>%
  summarise(
    upregulated = sum(DE_direction == 1),
    downregulated = sum(DE_direction == -1)
  ) %>%
  pivot_longer(-contrast, names_to = "DE_direction", values_to = "n_genes") %>%
  mutate(contrast_temp = readr::parse_number(contrast)) |> 
ggplot(aes(
  x = fct_rev(as.factor(contrast_temp)),
  y = n_genes,
  fill = DE_direction
)) +
  geom_col(position = "dodge") +
  theme_bw() +
  coord_flip() +
  geom_text(aes(label = n_genes),
            position = position_dodge(width = .9),
            hjust = "inward") +
  labs(y = "Number of DE genes") +
      ggtitle("Summary of gene expression changes over time") )
```

Do these results match what you'd expect to see? Maybe this will be easier as a direct comparison. We'll do that in the next section. But first, how do the expression time points compare with each other?

```{r}

res_all_transcriptome %>%
  as.matrix() %>%
  cor(use="pairwise.complete.obs") %>%
  corrplot::corrplot(method = "square", insig='blank',
         addCoef.col ='white', number.cex = 0.8,
         tl.srt=45,
         title="Correlation of Gene Expression between Time points in Heat Shock",
         # add this to make sure title isn't cut off
         mar=c(0,0,1,0))
```
Save list of genes that are DE for each time point for gene expression. I want to split genes that are upregulated and downregulated into separate lists.
```{r}
ID_transcriptome_list <- res_all_transcriptome %>%
  decideTests(p.value = 0.05, lfc = 1) %>%
  data.frame() %>%
  tibble::rownames_to_column("ORF") %>%
  tidyr::pivot_longer(-ORF,names_to="Time", values_to = "DE_direction") %>%
  mutate(Time = readr::parse_number(Time),
         DE_name = case_when(DE_direction == 1 ~ "up",
                             DE_direction == -1 ~ "down",
                             TRUE~NA),
         group=paste0("DE_",DE_name,"_",Time, "min")) %>%
  mutate(entrezID=AnnotationDbi::select(org.Sc.sgd.db,keys=ORF,columns="ENTREZID",
      multiVals = "first")$ENTREZID) %>%
  group_by(group) %>%
  filter(DE_direction != 0) %>%
  group_split() %>% # split into many lists
  purrr::set_names(purrr::map_chr(., ~.x$group[1])) %>% # assign names
  map(., ~ .x |> pull(all_of("ORF"))) # grab just the gene names

ID_transcriptome_list_up <- res_all_transcriptome %>%
  decideTests(p.value = 0.05, lfc = 1) %>%
  data.frame() %>%
  tibble::rownames_to_column("ORF") %>%
  tidyr::pivot_longer(-ORF,names_to="Time", values_to = "DE_direction") %>%
  mutate(Time = readr::parse_number(Time),
         DE_name = case_when(DE_direction == 1 ~ "up",
                             DE_direction == -1 ~ "down",
                             TRUE~NA),
         group=paste0("DE_",DE_name,"_",Time, "min")) %>%
  mutate(entrezID=AnnotationDbi::select(org.Sc.sgd.db,keys=ORF,columns="ENTREZID",
      multiVals = "first")$ENTREZID) %>%
  group_by(group) %>%
  filter(DE_direction > 0) %>%
  group_split() %>% # split into many lists
  purrr::set_names(purrr::map_chr(., ~.x$group[1])) %>% # assign names
  map(., ~ .x |> pull(all_of("ORF"))) # grab just the gene names

ID_transcriptome_list_down <- res_all_transcriptome %>%
  decideTests(p.value = 0.05, lfc = 1) %>%
  data.frame() %>%
  tibble::rownames_to_column("ORF") %>%
  tidyr::pivot_longer(-ORF,names_to="Time", values_to = "DE_direction") %>%
  mutate(Time = readr::parse_number(Time),
         DE_name = case_when(DE_direction == 1 ~ "up",
                             DE_direction == -1 ~ "down",
                             TRUE~NA),
         group=paste0("DE_",DE_name,"_",Time, "min")) %>%
  mutate(entrezID=AnnotationDbi::select(org.Sc.sgd.db,keys=ORF,columns="ENTREZID",
      multiVals = "first")$ENTREZID) %>%
  group_by(group) %>%
  filter(DE_direction < 0) %>%
  group_split() %>% # split into many lists
  purrr::set_names(purrr::map_chr(., ~.x$group[1])) %>% # assign names
  map(., ~ .x |> pull(all_of("ORF"))) # grab just the gene names
```


## Multi-omic comparison

Now, let's create a side-by-side DE gene total graph. Here is an easy way to combine graphs we've made. 
```{r}
library(ggpubr)
ggpubr::ggarrange(plot_summary_bars_transcriptome, plot_summary_bars_proteome,
          ncol=2, nrow=1, common.legend = TRUE, legend="bottom")
```

How do these data correlate with each other? Let's find out. To do this, we'll first need to do some data wrangling.
```{r}
res_all %>%
  as.matrix() %>%
  as.data.frame() %>%
  tibble::rownames_to_column("ORF") %>%
  full_join(res_all_transcriptome %>%
              as.matrix() %>%
              as.data.frame() %>%
              tibble::rownames_to_column("ORF"),
            by = "ORF"
  ) %>%
  #   dplyr::filter(ORF %in% c(list_c(ID_proteins_list)
  #                            # ,list_c(ID_transcriptome_list) 
  #                            )
  #                 ) %>%
  # dplyr::filter(ORF %in% list_c(ID_proteins_list)
  #                            & ORF %in% list_c(ID_transcriptome_list) 
  #                            # )
  #                 ) %>%
  # drop_na() %>%
  column_to_rownames("ORF") %>%
  as.matrix() %>%
  cor(#method = "spearman", 
      use="pairwise.complete.obs"
      ) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("group") %>%
  filter(str_detect(group, '.y')) %>%
  mutate(group=str_replace(group, ".y", "")) %>%
  mutate(group=str_replace(group, "time", "")) %>%
  dplyr::select(!contains(".y")) %>%
  rename_with(~str_remove(., '.x')) %>%
  rename_with(~str_remove(., 'time')) %>%
  column_to_rownames("group") %>%
  as.matrix() %>%
  corrplot::corrplot(method = "color", insig='blank',
                     is.corr=FALSE,
         addCoef.col ='black', 
         col=colorRampPalette(c("white","blue"))(200),
         col.lim=c(-0.01,1),
         number.cex = 0.8,
         tl.srt=45,
         title="Correlation of Protein and Gene Expression",
         # add this to make sure title isn't cut off
         mar=c(1,0,4,0)
         )
mtext(text = "mRNA (min)", side = 2, line = 0, at = 3.5, las = 0)
mtext(text = "Protein (min)", side = 3, line = 0, at =5, las = 0 )
```

Just upregulated mRNA genes 
```{r}
res_all %>%
  as.matrix() %>%
  as.data.frame() %>%
  tibble::rownames_to_column("ORF") %>%
  full_join(res_all_transcriptome %>%
              as.matrix() %>%
              as.data.frame() %>%
              tibble::rownames_to_column("ORF"),
            by = "ORF"
  ) %>%
  dplyr::filter(ORF %in% list_c(ID_transcriptome_list_up)
                  ) %>%
  column_to_rownames("ORF") %>%
  as.matrix() %>%
  cor(#method = "spearman", 
      use="pairwise.complete.obs"
      ) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("group") %>%
  filter(str_detect(group, '.y')) %>%
  mutate(group=str_replace(group, ".y", "")) %>%
  mutate(group=str_replace(group, "time", "")) %>%
  dplyr::select(!contains(".y")) %>%
  rename_with(~str_remove(., '.x')) %>%
  rename_with(~str_remove(., 'time')) %>%
  column_to_rownames("group") %>%
  as.matrix() %>%
  corrplot::corrplot(method = "color", insig='blank',
                     is.corr=FALSE,
         addCoef.col ='black', 
         col=colorRampPalette(c("red","white","blue"))(200),
         col.lim=c(-1,1),
         number.cex = 0.8,
         tl.srt=45,
         title="Correlation of Protein and Gene Expression (upregulated genes)",
         # add this to make sure title isn't cut off
         mar=c(1,0,4,0)
         )
mtext(text = "mRNA (min)", side = 2, line = 0, at = 3.5, las = 0)
mtext(text = "Protein (min)", side = 3, line = 0, at =5, las = 0 )
```

Look at correlations of genes that were downregulated at the mRNA level.
```{r}
res_all %>%
  as.matrix() %>%
  as.data.frame() %>%
  tibble::rownames_to_column("ORF") %>%
  full_join(res_all_transcriptome %>%
              as.matrix() %>%
              as.data.frame() %>%
              tibble::rownames_to_column("ORF"),
            by = "ORF"
  ) %>%
  dplyr::filter(ORF %in% list_c(ID_transcriptome_list_down)
                  ) %>%
  column_to_rownames("ORF") %>%
  as.matrix() %>%
  cor(#method = "spearman", 
      use="pairwise.complete.obs"
      ) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("group") %>%
  filter(str_detect(group, '.y')) %>%
  mutate(group=str_replace(group, ".y", "")) %>%
  mutate(group=str_replace(group, "time", "")) %>%
  dplyr::select(!contains(".y")) %>%
  rename_with(~str_remove(., '.x')) %>%
  rename_with(~str_remove(., 'time')) %>%
  column_to_rownames("group") %>%
  as.matrix() %>%
  corrplot::corrplot(method = "color", insig='blank',
                     is.corr=FALSE,
         addCoef.col ='black', 
         col=colorRampPalette(c("red","white","blue"))(200),
         col.lim=c(-1,1),
         number.cex = 0.8,
         tl.srt=45,
         title="Correlation of Protein and Gene Expression (downregulated genes)",
         # add this to make sure title isn't cut off
         mar=c(1,0,4,0)
         )
mtext(text = "mRNA (min)", side = 2, line = 0, at = 3.5, las = 0)
mtext(text = "Protein (min)", side = 3, line = 0, at =5, las = 0 )
```






## Questions

Question 1: How many genes were upregulated and downregulated in the
contrast we looked at in today's activity? Be sure to clarify the
cutoffs used for determining significance.

Question 2: What are the pros and cons of applying a logFC cutoff to a
differential expression analysis?

Be sure to knit this file into a pdf or html file once you're finished.

System information for reproducibility:

```{r sessionInfo-limma}
pander::pander(sessionInfo())
```
