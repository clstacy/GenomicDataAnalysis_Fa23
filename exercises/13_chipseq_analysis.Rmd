---
title: "ChIP-seq Analysis"
author: "Carson Stacy & Jeffrey Lewis"
date: "Fall 2023"
output:
  html_document:
    code_folding: show
    embed-resources: true
editor_options:
  markdown:
    wrap: 72
---

last updated: `r Sys.Date()`

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Description

In this class exercise, we will practice analyzing ChIP-seq data.

## Learning Outcomes

At the end of this exercise, you should be able to:

-   

## Exercise Background

In this exercise, we will look at the only published ChIP-seq data for
Msn2/4 mutants under EtOH stress conditions similar to those we have
been exploring throughout this course. The data comes from []. We will
go through this analysis together, starting from the raw fastq files.

## Pre-Analysis Preparations

Before analyzing our ChIP-seq results, we need to prepare our computing
environment for this analysis.

### Prepare Software

This analysis will use both R and terminal based commands.

#### R packages

```{r ready-packages}
# Ensure required packages are installed
if (!require("pacman")) install.packages("pacman"); library(pacman)

if (!require("TxDb.Scerevisiae.UCSC.sacCer3.sgdGene", quietly = TRUE))
  p_install("TxDb.Scerevisiae.UCSC.sacCer3.sgdGene")
if (!require("ChIPseeker", quietly = TRUE))
  p_install("ChIPseeker")

# Load necessary packages
# p_load("tidyverse", "knitr", "readr", "pander", "BiocManager", 
#        "dplyr", "stringr", #"purrr", "reactable",
#        "biomaRt", "memes", "Biostrings", "curl", "universalmotif")

# library(biomaRt)
# library(memes)
# library(curl)
# library(universalmotif)
library(tidyverse)
library(ShortRead) # added by me, using rockerfeller approach.
# p_install("ChIPQC")
# p_install("ChIPseeker")
# library(ChIPQC)
library(ChIPseeker)
# library(DiffBind)
library(clusterProfiler)
library(AnnotationDbi)
p_load("Rfastp", "Rsubread")
p_load("memes", "universalmotif")
p_load("plyranges", "biomaRt")
library(Rsubread)
library(Rfastp)
library(TxDb.Scerevisiae.UCSC.sacCer3.sgdGene)
library(GenomicRanges)
```

#### Conda environments

Similar to exercise 03_Working_with_Sequences.Rmd, we need to use
software that aren't available in R. One way to do that is the way shown
here, creating and activating conda environments. If you haven't done
set-up of conda on your system as described in exercise 03, this code
likely won't run for you.

##### FastQC

```{bash create-QCcondaEnvironment, engine.opts='-l'}
# create an enviornment for our QC packages
if conda info --envs | grep -q QC; then echo "environment 'QC' already exists"; else conda create -y -n QC fastqc multiqc; fi

# see available conda environments
conda env list

# activate our QC environment
conda activate QC

# make sure desired packages are working
which fastqc
which multiqc

# get the versions of each software
fastqc -v
multiqc --version

# it's always good coding practice to deactivate a conda environment at the end of a chunk
conda deactivate
```

##### MACS2

A popular software for peak-calling ChIP-seq data is
[MACS2](https://pypi.org/project/MACS2/). It uses a Poisson
distribution-based model to background identify significant peaks in
ChIP-seq data.

```{bash create-MACS2condaEnvironment, engine.opts='-l'}
# create an enviornment for our QC packages
if conda info --envs | grep -q MACS; then echo "environment 'MACS' already exists"; else conda create -y -n MACS macs2 -c bioconda; fi

# see available conda environments
conda env list

# activate our MACS environment
conda activate MACS

# make sure desired package is working
which macs2

# get the versions of each software
macs2 --version

# it's always good coding practice to deactivate a conda environment at the end of a chunk
conda deactivate
```

### Data Retreival

For today's exercise, the software Model-based Analysis of ChIP-seq (MACS) will be doing the ChIP-seq specific part of our analysis. MACS needs .bam files as input, which we can generate in the same way as we did in the 04_Read_Mapping.Rmd exercise. However, we get .fastq files from sequencing, so we have to align the fastq files to the genome. A supplement 

#### fastq files

We will be using paired-end fastq files from the publication
<https://academic.oup.com/nar/article/42/9/5468/1246885>, with
experiment SRA accession SRP033438. Specifically, we will be getting
time 0 minutes and time 20 minutes post glucose to glycerol shift, which
induces the ESR. These samples have the names SRR1181480 and SRR1181481
respectively.

We could use the SRA toolkit to download these files (tutorial
[here](https://erilu.github.io/python-fastq-downloader/#automating-downloads-using-python)).

An alternative approach we can use to download these files is going to
<https://www.ebi.ac.uk/ena/browser/view/SRR1181480> and
<https://www.ebi.ac.uk/ena/browser/view/SRR1181481> to either download
the files manually, or download the bash script that we can use to
download the files. We will use a modified version of that code to
download the files today.

```{bash fetch-fastq-chipseq}
# Be sure to change this file path to the path you want your data to go
RAW_DATA_DIR="/Users/$USER/Desktop/Genomic_Data_Analysis/Data/Raw/ChIP"
# if you're using Windows 10,
# in RStudio, go to Tools>Global Options... > Terminal > New Terminals open with...
# and choose WSL bash or git bash
# next, use: (be sure to put in the correct username)
#RAW_DATA_DIR="/mnt/c/Users/$USER/Desktop/Genomic_Data_Analysis/Data/Raw"

# create the destination directory if it doesn't already exist
mkdir -p $RAW_DATA_DIR

# change to that directory (for this code chunk only)
cd $RAW_DATA_DIR
pwd
# Download the files.
# WARNING: curl doesn't work with relative paths

# T=0 read 1
if [ ! -f "$RAW_DATA_DIR/SRR1181480_1.fastq.gz" ]; then
    echo "fastq file SRR1181480_1.fastq.gz not found, downloading..."
    # If the file does not exist, download it using curl
    wget -nc ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR118/000/SRR1181480/SRR1181480_1.fastq.gz
    echo "Downloading finished"
else
    echo "File SRR1181480_1.fastq.gz already exists at $RAW_DATA_DIR Skipping download."
fi

#T=0 read 2
if [ ! -f "$RAW_DATA_DIR/SRR1181480_2.fastq.gz" ]; then
    echo "fastq file SRR1181480_2.fastq.gz not found, downloading..."
    # If the file does not exist, download it using curl
    wget -nc ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR118/000/SRR1181480/SRR1181480_2.fastq.gz
    echo "Downloading finished"
else
    echo "File SRR1181480_2.fastq.gz already exists at $RAW_DATA_DIR Skipping download."
fi

# T=20 read 1
if [ ! -f "$RAW_DATA_DIR/SRR1181481_1.fastq.gz" ]; then
    echo "fastq file SRR1181481_1.fastq.gz not found, downloading..."
    # If the file does not exist, download it using curl
    wget -nc ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR118/001/SRR1181481/SRR1181481_1.fastq.gz
    echo "Downloading finished"
else
    echo "File SRR1181481_1.fastq.gz already exists at $RAW_DATA_DIR Skipping download."
fi

#T=20 read 2
if [ ! -f "$RAW_DATA_DIR/SRR1181481_2.fastq.gz" ]; then
    echo "fastq file SRR1181481_2.fastq.gz not found, downloading..."
    # If the file does not exist, download it using curl
    wget -nc ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR118/001/SRR1181481/SRR1181481_2.fastq.gz
    echo "Downloading finished"
else
    echo "File SRR1181481_2.fastq.gz already exists at $RAW_DATA_DIR Skipping download."
fi

# see all downloaded files
ls -lah
```


#### Reference files

\#####**Genome**

```{bash fetch-genome-chipseq}
# Define the destination file path
# You can change this file path to the path you want your data to go, or leave it.
REF_DIR="/Users/$USER/Desktop/Genomic_Data_Analysis/Reference"

# make that directory if it doesn't already
mkdir -p $REF_DIR

# Define the URL of reference genome
# (latest from ensembl)
url="ftp://ftp.ensembl.org/pub/release-110/fasta/saccharomyces_cerevisiae/dna/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa.gz"


# Check if the file already exists at the destination location
if [ ! -f "$REF_DIR/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa.gz" ]; then
    echo "Reference genome not found, downloading..."
    # If the file does not exist, download it using curl
    curl -o "$REF_DIR/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa.gz" "$url"
    echo "Downloading finished"
else
    echo "File already exists at $REF_DIR Skipping download."
fi
```

\#####**blacklist**

ChIPseq will often show the presence of common artifacts, such as ultra-high signal regions. Such regions can confound peak calling, fragment length estimation and QC metrics. Anshul Kundaje created the DAC blacklist as a reference to help deal with these regions. These are available for dm3, dm6, ce10, ce11, mm10, hg19, and hg38. (https://zenodo.org/records/1491733).

*Saccharomyces cerevesiae* doesn't have an official blacklist, so we won't be using this today.



### QC & Trimming

We can use **FastQC** to do quality control for fastq files generated in ChIP-seq experiments. For the sake of time in class, we will skip using  FastQC on the reads today. We can look at the rfastp QC reports in 

Get paths to all of our read files, split by read 1 and read 2.
```{r}
# assign directory with the raw fastq files
fq_file_dir <- path.expand("~/Desktop/Genomic_Data_Analysis/Data/Raw/ChIP")

# assign read 1 and read 2 paths into objects
fq_read1_files <- list.files(fq_file_dir, full.names = TRUE, pattern = "*_1.fastq.gz")
fq_read2_files <- list.files(fq_file_dir, full.names = TRUE, pattern = "*_2.fastq.gz")
```

#### Trim with rfastp

We can use rfastp to trim and QC all of our files, by slightly modifying the original rfastp command we used for rnaseq data. The only major modification is including the read2 in rfastp. QC reports and trimmed fastq files will appear in the dir_trimmed.fq_files folder.

```{r}
# create a directory for the output to go into if not already present
dir_trimmed.fq_files <- path.expand("~/Desktop/Genomic_Data_Analysis/Data/Trimmed/ChIP")
if (!dir.exists(dir_trimmed.fq_files)) {dir.create(dir_trimmed.fq_files, recursive = TRUE)}

# run rfastp on all fastq files
for (i in 1:length(fq_read1_files)) {
  # file path to each file for paired end reads
  read1 <- fq_read1_files[i]
  read2 <- fq_read2_files[i]
  # assign output file (putting it inside of dir_trimmed.fq_files folder)
  output_name <- paste0(dir_trimmed.fq_files,
                        "/",
                        basename(fq_read1_files[i])) |>
                          str_replace("_1", "")
  json_report <- rfastp(
    read1 = read1,
    read2 = read2,
    outputFastq = str_split(output_name, fixed("."))[[1]][1],
    disableTrimPolyG = FALSE,
    cutLowQualFront = TRUE,
    cutLowQualTail = TRUE,
    minReadLength = 15
  )
  
  # Print the output file link in the R Markdown document
  cat(paste0(
    "[Processing Complete - ",
    basename(output_name),
    "](",
    output_name,
    ")\n\n"
  ))
}
```

### Map to Reference

Assign the read1 trimmed fastq files to a list in R called trimmed_fastq_files_R1, and we'll do the same for read2 fastq files.

```{r}
# find our trimmed fastq files
trimmed_fastq_files_R1 <- list.files(path = dir_trimmed.fq_files, 
                                  pattern = "_R1.fastq.gz$", 
                                  full.names = TRUE)


trimmed_fastq_files_R2 <- list.files(path = dir_trimmed.fq_files, 
                                  pattern = "_R2.fastq.gz$", 
                                  full.names = TRUE)

# print them out
trimmed_fastq_files_R1
trimmed_fastq_files_R2

```

#### Build Genome Index for Rsubread

We have already done this in the Read_mapping.Rmd exercise. If you've already created this, we can skip this step.
```{r}
# Set path of the reference fasta file
reference_genome = path.expand("~/Desktop/Genomic_Data_Analysis/Reference/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa.gz")

index_reference_genome = path.expand("~/Desktop/Genomic_Data_Analysis/Reference/index_rsubread_Saccharomyces_cerevisiae.R64-1-1")

# build the index
buildindex(basename=index_reference_genome, reference=reference_genome)
```


#### Align trimmed files to the reference genome.
```{r}
# run the alignment on all of the trimmed_fastq_files
align(index=index_reference_genome, 
      readfile1=trimmed_fastq_files_R1,
      readfile2=trimmed_fastq_files_R2,
      type = "dna",
      input_format = "gzFASTQ",
      output_format = "BAM",
      unique = TRUE,
      nBestLocations = 1,
      sortReadsByCoordinates = TRUE,
      nthreads=6
      )

# Create new directory to store mapping .bam files
dir_bam_files <- path.expand("~/Desktop/Genomic_Data_Analysis/Data/Bam/ChIP")
if (!dir.exists(dir_bam_files)) {dir.create(dir_bam_files, recursive = TRUE)}
```

Move output files into bam file directory
```{bash}
trim_fq_dir=~/Desktop/Genomic_Data_Analysis/Data/Trimmed/ChIP
bam_dir=~/Desktop/Genomic_Data_Analysis/Data/Bam/ChIP/
mv $trim_fq_dir/*.BAM* $bam_dir
```

Save the paths to our bam files as an object.
```{r}
bam_files <- list.files(path = dir_bam_files, pattern = ".BAM$", full.names = TRUE)
bam_files
```

## Peak Calling

Now, we are able to call peaks with MACS2.

To run MACS2 to we need to supply:
      
    1. A BAM file to find enriched regions in. (specified after -t)
      a. (this is the only REQUIRED parameter for MACS)
    2. A Name for peak calls (specified after –name).
    3. An output folder to write peaks into (specified after –outdir).
    4. Optionally, but highly recommended, we can identify a control to compare to (specified after –c).


In this analysis, we only need to do a single call to macs2 because we only have one treatment sample and one control sample. If we had more samples, we'd want to run macs2 for every sample.

For the purpose of demonstration, we will run macs2 on each sample with no control. THIS IS NOT RECOMMENDED. For this analysis, we should just use the third call to macs2 below. We are running the noControl's so we can look at the peaks that would be called for each alone, so we can compare them to the peaks of the treatment vs control.

flags for MACS2:
    - `-n` output file name prefix
    - `--outdir` path to where output files should be saved
    - `f` type of files being input. Usually `BAM` (or `BAMPE` for paired-end.)
    - `g` is the genome size. this has been set for yeast genome
    - `B` output bedgraph files
    - `--nomodel` MACS will bypass building the shifting model.
    - `extsize` While --nomodel is set, MACS uses this parameter to extend reads in 5'->3' direction to fix-sized fragments.
    
```{bash run-MACS2-chip, engine.opts='-l'}
# activate our MACS environment
conda activate MACS

macs_outdir=/Users/$USER/Desktop/Genomic_Data_Analysis/Analysis/ChIP/

# run macs on the 0 minutes sample, no control
macs2 callpeak -t "/Users/$USER/Desktop/Genomic_Data_Analysis/Data/Bam/ChIP/SRR1181480_R1.fastq.gz.subread.BAM" \
  -n MSN24_ESR_t0_noControl \
  --outdir $macs_outdir \
  -f BAMPE \
  -g 1.2e7 \
  -B \
  --nomodel \
  --extsize 50


# run macs on the 20 minutes sample, no control
macs2 callpeak -t "/Users/$USER/Desktop/Genomic_Data_Analysis/Data/Bam/ChIP/SRR1181481_R1.fastq.gz.subread.BAM" \
               -n MSN24_ESR_t20_noControl \
               --outdir $macs_outdir \
               -f BAMPE \
               -g 1.2e7 \
               -B \
               --nomodel \
               --extsize 50


# run macs with 20 min as treatment and 0 min as control
macs2 callpeak -t "/Users/$USER/Desktop/Genomic_Data_Analysis/Data/Bam/ChIP/SRR1181481_R1.fastq.gz.subread.BAM" \
               -n MSN24_ESR_t20vst0 \
               -c "/Users/$USER/Desktop/Genomic_Data_Analysis/Data/Bam/ChIP/SRR1181480_R1.fastq.gz.subread.BAM" \
               --outdir $macs_outdir \
               -B \
               -f BAMPE \
               -g 1.2e7
               


# Rename all *.bdg to *.bedgraph for IGV visualization
for file in ${macs_outdir}*.bdg; do
   mv -- "$file" "${file%.bdg}.bedgraph"
done

```


## Working with Peaks in R

We can use R to analyze the peaks generated by macs2. There are many approaches for doing this. We will use the `ChIPSeeker` package, followed by tools we've previously used for downstream analysis.

### Importing Peaks

MACS peak calls can be found in our specified output directory with the suffix and extension "_peaks.xls".
MACS peaks come as a tab separated file (thinly disguised as a “.xls”).
In addition to the genomic coordinates of peaks, these files contain useful information on the samples, parameters and version used for peak calling at the top.

```{r}
MSN24_ESR_t20vst0_peaks <- read.delim("~/Desktop/Genomic_Data_Analysis/Analysis/ChIP/MSN24_ESR_t20vst0_peaks.xls", header = TRUE, comment.char = "#") |>
  # only take highest confidence peaks
  filter(X.log10.pvalue. > 5) |>
  # filter(length > 800)
  # filter(X.log10.pvalue. > 5)
  filter(fold_enrichment > 4)
```


### Filtering **blacklisted** regions

no peaks were detected in the blacklisted region, so none are filtered out.

```{r}
# MSN24_ESR_t20vst0_peaks_filtered <- MSN24_ESR_t20vst0_peaks %>%
#   filter(chr != "XII" | end <= 451787 | start >= 468932)
```


### Peak annotation

## Visualization

### Assess Alignment with IGV

Another method for assessing the quality of your alignment is to
visualize the alignment using a genome browser. For this workshop we
will be using the Integrative Genomics Viewer (IGV) from the Broad
Institute. You should already have this downloaded on your laptop. IGV
is an interactive tool which allows exploration of large, integrated
genomic datasets. It supports a wide variety of data types, including
array-based and next-generation sequence data, and genomic annotations,
which facilitates invaluable comparisons.

## Downstream Analysis

ChIP peaks in R: Let's generate a gene list corresponding to peaks that
appear in t20 minutes but not t0 minutes.

### Gene Set Enrichment

```{r}
# BiocManager::install("ChIPpeakAnno")
# set up custom anno for QC results
library(TxDb.Scerevisiae.UCSC.sacCer3.sgdGene)
library(GenomicRanges)
# library(ChIPpeakAnno)
txdb <- TxDb.Scerevisiae.UCSC.sacCer3.sgdGene
MSN24_ESR_t20vst0_peaks_GR <- GRanges(seqnames=MSN24_ESR_t20vst0_peaks %>%
  mutate(chr = paste0("chr", chr)) %>% pull(chr),
                        IRanges(MSN24_ESR_t20vst0_peaks[,"start"],MSN24_ESR_t20vst0_peaks[,"end"]))


genes(txdb) |> str()

library(ChIPseeker)
peakAnno <- annotatePeak(MSN24_ESR_t20vst0_peaks_GR, tssRegion=c(-3000, 3000), level = "gene",
                         TxDb=txdb)#,# annoDb="org.Sc.sgd.db")

plotAnnoPie(peakAnno)
vennpie(peakAnno)
p_load(ggimage)
upsetplot(peakAnno, vennpie=TRUE)

plotDistToTSS(peakAnno,
              title="Distribution of transcription factor-binding loci\nrelative to TSS")
```
```{r eval = FALSE}
promoter <- getPromoters(TxDb=txdb, upstream=500, downstream=500)
tagMatrix <- getTagMatrix(MSN24_ESR_t20vst0_peaks_GR, windows=promoter)
tagHeatmap(tagMatrix)
```



We can extract the unique names of genes with peaks in their TSS by
subsetting the annotated GRanges and retrieving gene names from the
geneId column.

```{r}
peak_genes <- peakAnno |>
  as.data.frame() |>
  pull(geneId)
```

Now, let's extract all genes which are included in the TxDb object to
use as our universe of genes for pathway enrichment.


#### Gene Ontology

```{r}

library(clusterProfiler)
# Run our GO enrichment
go_results <- enrichGO(
  gene = peak_genes,
  OrgDb = "org.Sc.sgd.db",
  keyType = "ORF",
  ont = "ALL"
) |>
  # let's add a 'richFactor' column that gives us the proportion of genes DE in the term
  mutate(richFactor = Count / as.numeric(sub("/\\d+", "", BgRatio)))

# take a peak at the results
head(go_results)

# create a table for the html file
data.frame(go_results) %>% View()


dotplot(go_results, showCategory = 10)

# visualize top GO terms
ggplot(go_results,
       showCategory = 15,
       aes(richFactor, fct_reorder(Description, richFactor))) +
  geom_segment(aes(xend = 0, yend = Description)) +
  geom_point(aes(color = p.adjust, size = Count)) +
  scale_color_gradientn(
    colours = c("#f7ca64", "#46bac2", "#7e62a3"),
    trans = "log10",
    guide = guide_colorbar(reverse = TRUE, order = 1)
  ) +
  scale_size_continuous(range = c(2, 10)) +
  xlab("Rich Factor") +
  ylab(NULL) +
  ggtitle("Enriched GO Categories") +
  theme_bw()

```

#### KEGG

```{r enrich-KEGG-chip}
library(clusterProfiler)
# Run our KEGG enrichment
kegg_results <- enrichKEGG(gene = peak_genes,
                           organism = 'sce' #options: https://www.genome.jp/kegg/catalog/org_list.html
                           )

# take a peak at the results
head(kegg_results)

# create a table for the html file
data.frame(kegg_results) %>% reactable::reactable()


# Remove " - Saccharomyces cerevesiae" from each description entry
kegg_results@result$Description <- kegg_results@result$Description %>% print() %>% str_replace_all(., fixed(" - Saccharomyces cerevisiae"), "")


# browseKEGG(kegg_results, 'sce04213')  # longevity
# browseKEGG(kegg_results, 'sce00500')  # Starch and sucrose metabolism 


dotplot(kegg_results, showCategory = 10) 

```


### Motif Analysis

The MEME-suite that we used in a previous motif analysis exercise has a
specific algorithm for ChIP-seq analysis, called MEME-ChIP

```{r}
# MEME-ChIP

if (!require("BSgenome.Scerevisiae.UCSC.sacCer3", quietly = TRUE))
    install.packages("BSgenome.Scerevisiae.UCSC.sacCer3")

library(BSgenome.Scerevisiae.UCSC.sacCer3)

sacCer3.genome <- BSgenome.Scerevisiae.UCSC.sacCer3::BSgenome.Scerevisiae.UCSC.sacCer3

# use memes to grab sequences
peak_seqs <- memes::get_sequence(MSN24_ESR_t20vst0_peaks_GR,sacCer3.genome)



# Get sequences in a 100bp window around the peak summit
summit_flank <- MSN24_ESR_t20vst0_peaks_GR %>%
  # this ensures we take 100bp up & downstream of the summit for a total width of 200bp
  plyranges::anchor_center() %>%
  # plyranges::anchor_start() %>%
  plyranges::mutate(width = 800) #%>%
  # plyranges::mutate(start= max(start,0))

summit_flank@ranges@start[summit_flank@ranges@start < 0] <- 1L

# get the sequences
peak_seqs_flanks <- memes::get_sequence(summit_flank,sacCer3.genome)
```

We can use Meme to analyze the promoters of those genes corresponding to
enrichment peaks.


Let's create a folder to which we can save output files. 
```{r create-outdir-motif-chip}
# Choose output directory for the output files to be saved
out_dir <- path.expand("~/Desktop/Genomic_Data_Analysis/Analysis/memes/ChIP_msn24/")

# Create out_dir directory if doesn't already exist
if (!dir.exists(out_dir)) {
  dir.create(out_dir, recursive = TRUE)
}
```


```{r make-background-genes-motif}
# # create a DNAStringSet object from our FC_list we created above.
# # background_fa <- DNAStringSet(left_join(FC_list,seq, by=c("ID" = "ensembl_gene_id")) |>
# #                                        drop_na("coding_gene_flank") |> pull(coding_gene_flank))
# 
# # background_fa <- memes::get_sequence(GRanges(seqinfo(sacCer3.genome)), sacCer3.genome)
# 
# 
# promoter <- getPromoters(TxDb=txdb, upstream=50, downstream=200)
# # background_fa <- memes::get_sequence(promoter, sacCer3.genome)
# 
# 
# # add gene names
# # names(background_fa) <- left_join(FC_list,seq, by=c("ID" = "ensembl_gene_id")) |>
# #                                        drop_na("coding_gene_flank") |> pull(ID)
# 
# txdb <- TxDb.Scerevisiae.UCSC.sacCer3.sgdGene
# 
# # get 500 random genes from yeast genome
# set.seed(123)
# random_500_yeast_genes <- genes(txdb) |> data.frame() |> pull(gene_id) |>
#   sample(500)
# 
# 
# ensembl <- biomaRt::useEnsembl(biomart = "genes",
#                       dataset = "scerevisiae_gene_ensembl")
# 
# 
# # grab their promoter sequences 200bp upstream
# 
# background_genes_fa <- getSequence(id = random_500_yeast_genes,
#                  type="ensembl_gene_id",
#                  seqType="coding_gene_flank",
#                  downstream=200,
#                  mart=ensembl,
#                  useCache = TRUE) |>
#   drop_na() |>
#   dplyr::filter(coding_gene_flank != "Sequence unavailable") |>
#   pull(coding_gene_flank,name = ensembl_gene_id) |>
#   DNAStringSet()
# 
# 
# test_using_promoter_seqs_from_ensembl <- getSequence(id = peak_genes,
#                  type="ensembl_gene_id",
#                  seqType="coding_gene_flank",
#                  upstream=1000,
#                  mart=ensembl,
#                  useCache = TRUE) |>
#   drop_na() |>
#   dplyr::filter(coding_gene_flank != "Sequence unavailable") |>
#   pull(coding_gene_flank,name = ensembl_gene_id) |>
#   DNAStringSet()
```

```{r run-streme-motif}
# Run Streme
streme_msn24_ChIP <- runStreme(peak_seqs, #_flanks
        # control= background_genes_fa,
        control="shuffle",
        minw = 5, # default is 8, for yeast I use 5
        maxw= 10, #default is 15, for yeast I use 20
        parse_genomic_coord=FALSE,
        silent=TRUE,
        outdir = path.expand(paste0(out_dir, "streme_msn24_ChIP_diauxic"))
        )

# Display Streme results
streme_msn24_ChIP |> View() 

# Run Meme-Chip
```

### TomTom

```{r fig.height=12, fig.width=5}
# path to yeastract
db_destination <-
  path.expand("~/Desktop/Genomic_Data_Analysis/Reference/YEASTRACT_20130918.meme")

# Run TomTom on motifs found by runStreme()
streme_tomtom_msn24_ChIP <-
  runTomTom(
    input = streme_msn24_ChIP,
    motif_pseudo = 0.1,
    database = db_destination,
    outdir = path.expand(paste0(out_dir, "tomtom_streme_msn24_ChIP"))
  )

# View Streme TomTom results
# universalmotif::view_motifs(streme_tomtom_msn24_ChIP$best_match_motif,
#             # relative_entropy = FALSE, 
#             normalise.scores = TRUE#, 
#             # use.type = "ICM", 
#             # method = "WPCC",
#             # tryRC = FALSE
#             )

##TODO: use chip-meme tutorial to get just seq surrounding peaks.
## also maybe try filtering based on pvalue the peaks to get fewer of them.

## alrigth all the above completed.
## what i found is weak enrichmetn for msn2 signal in the peak when getting 200bp surrounding peak
## really interesting is some peaks really wide
## when just looking at those peaks, we see bonkers enrichment for trehalose genes.
```


# Questions

1.  What is the difference in motifs when you change the settings for
    analyzing the msn2/4 mutant vs wild-type ethanol response using
    "zoops" or "anr" as the setting?

2.  Perform MEME and STREME on the wild-type salt response and wild-type
    ethanol response (using a log2 FC of 3 and FDR \< 0.01) to identify
    motifs in genes that are strongly induced for each stress, and then
    follow that analysis with TOMTOM. What TFs may be shared and what
    TFs may be different between the two stress responses?

Be sure to knit this file into a pdf or html file once you're finished.

System information for reproducibility:

```{r session-info}
pander::pander(sessionInfo())
```
